!-------------------------------------------------------------------------------
! Name: read_prtm.F90
!
! Purpose:
! Reads the profile Radiative Transfer Model (atmospheric) file and loads
! appropriate data arrays.
!
! Description and Algorithm details:
! 1) Open the PRTM file.
! 2) Read wavelength-independent fields from the PRTM file.
! 3) Close the PRTM file.
!
! Arguments:
! Name    Type         In/Out/Both Description
! ------------------------------------------------------------------------------
! Ctrl    struct       Both        Control structure
! RTM     alloc struct Out         RTM structure
!
! History:
! 2014/04/27, AP: Original version forked from ReadLwRTM_nc.F90.
! 2015/09/07, AP: Allow verbose to be controlled from the driver file.
!
! Bugs:
! None known.
!-------------------------------------------------------------------------------

subroutine Read_PRTM(Ctrl, RTM)

   use Ctrl_m
   use ORAC_Constants_m
   use orac_ncdf_m

   implicit none

   ! Argument declarations

   type(Ctrl_t), intent(in)  :: Ctrl
   type(RTM_t),  intent(out) :: RTM

   ! Local variables

   ! Note on values read from the binary Lw and P RTM files. These files are
   ! generated by RTTOV code, which is compiled with a flag to force reals to
   ! become real(8). The parameter arrays read in via buf, and the lat/lons
   ! etc are explicitly written as real(4) in order to reduce the file size.

   integer                  :: ncid, i
   real(sreal), allocatable :: dummy1d(:)


   ! Open PRTM file
   call ncdf_open(ncid, Ctrl%FID%PRTM, 'Read_PRTM()')

   ! Allocate arrays
   allocate(RTM%lat(RTM%Grid%NLon, RTM%Grid%NLat))
   allocate(RTM%lon(RTM%Grid%NLon, RTM%Grid%NLat))

   allocate(RTM%P(RTM%NP, RTM%Grid%NLon, RTM%Grid%NLat))
   allocate(RTM%T(RTM%NP, RTM%Grid%NLon, RTM%Grid%NLat))
   allocate(RTM%H(RTM%NP, RTM%Grid%NLon, RTM%Grid%NLat))

   ! Read data into arrays
   allocate(dummy1d(RTM%Grid%NLon))
   call ncdf_read_array(ncid, "lon_rtm", dummy1d, Ctrl%verbose)
   do i=1,RTM%Grid%NLon
      RTM%lon(i,:) = dummy1d(i)
   end do
   deallocate(dummy1d)

   allocate(dummy1d(RTM%Grid%NLat))
   call ncdf_read_array(ncid, "lat_rtm", dummy1d, Ctrl%verbose)
   do i=1,RTM%Grid%NLat
      RTM%lat(:,i) = dummy1d(i)
   end do
   deallocate(dummy1d)

   call ncdf_read_array(ncid, "pprofile_rtm", RTM%P, Ctrl%verbose)
   call ncdf_read_array(ncid, "tprofile_rtm", RTM%T, Ctrl%verbose)
   call ncdf_read_array(ncid, "hprofile_rtm", RTM%H, Ctrl%verbose)

   ! Close PRTM input file
   call ncdf_close(ncid, 'Read_PwRTM()')

   ! Calculate grid parameters

   ! Corners of the grid
   RTM%Grid%Lat0 = real(RTM%Lat(1,1), kind=8)
   RTM%Grid%LatN = real(RTM%Lat(1,RTM%Grid%NLat), kind=8)
   RTM%Grid%Lon0 = real(RTM%Lon(1,1), kind=8)
   RTM%Grid%LonN = real(RTM%Lon(RTM%Grid%NLon,1), kind=8)

   ! Grid spacing and inverse
   RTM%Grid%delta_Lat = (RTM%Grid%LatN - RTM%Grid%Lat0) / (RTM%Grid%NLat-1)
   RTM%Grid%inv_delta_Lat = 1. / RTM%Grid%delta_Lat

   RTM%Grid%delta_Lon = (RTM%Grid%LonN - RTM%Grid%Lon0) / (RTM%Grid%NLon-1)
   RTM%Grid%inv_delta_Lon = 1. / RTM%Grid%delta_Lon

   ! Max and Min grid values
   RTM%Grid%MinLat = min(RTM%Grid%Lat0-0.5*RTM%Grid%delta_Lat, &
                            RTM%Grid%LatN+0.5*RTM%Grid%delta_Lat)
   RTM%Grid%MaxLat = max(RTM%Grid%Lat0-0.5*RTM%Grid%delta_Lat, &
                            RTM%Grid%LatN+0.5*RTM%Grid%delta_Lat)
   RTM%Grid%MinLon = min(RTM%Grid%Lon0-0.5*RTM%Grid%delta_Lon, &
                            RTM%Grid%LonN+0.5*RTM%Grid%delta_Lon)
   RTM%Grid%MaxLon = max(RTM%Grid%Lon0-0.5*RTM%Grid%delta_Lon, &
                            RTM%Grid%LonN+0.5*RTM%Grid%delta_Lon)

   ! Does the grid wrap around the international date-line?
   RTM%Grid%Wrap = RTM%Grid%MinLon <= -180. .and. &
                   RTM%Grid%MaxLon >=  180.

end subroutine Read_PRTM
