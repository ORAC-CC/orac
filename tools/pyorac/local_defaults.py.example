"""Definitions of default values and paths for your local system.

The pyORAC scripts are designed to make it easy to run ORAC by automating
the process of locating all the necessary input files, generating correctly
formatted driver files, and setting up environment variables so the executables
can link against the correct libraries. Doing all of that requires knowing
where to find various things, and this file is where that information is kept.

Following Python style, global variables are in block capitals. Temporary
variables that are used to generate other variables, but aren't expected to be
used themselves, are prefixed with an underscore.

The first section defines a selection of paths that point the scripts to the
   various input files requires by ORAC.
The second section defines the metadata that goes in every ORAC output file.
The third section defines the names of subfolders that will be generated by
   these scripts.
The fourth section defines the default retrieval settings. Only experienced
   users should alter these but feel free to add your own options.
The fifth section defines the default channels to read from each sensor. Though
   different retrievals use different channels, for consistent cloud flagging
   one should read the same set of channels for any processing.
The sixth section sets up the regression tests.
The seventh section specifies the batch processing system to use.
The eighth selection defines the LUTs available on your local system.
"""

# ============================ PATHS ======================================
# Location of your copy of the ORAC repository. This is used to find executables.
ORAC_DIR = '/home/username/orac/orac'

# regression.py calls a set of predefined regression tests. The L1 files for
# those tests are expected to be found in a single folder (which could be
# symlinks to a more rational location), which is defined here.
REGRESS_IN_DIR = '/local/storage/orac/data'

# We also define a default output folder for the regression tests, as they
# want to find the output of previous regression tests to compare against.
REGRESS_OUT_DIR = '/local/storage/orac/regression_tests'

# Path to the library file used to compile ORAC. This is used by
# pyorac.util.build_orac_library_path() to set LD_LIBRARY_PATH. You can just
# type of the full path to your library file,
ORAC_LIB = '/home/username/orac/orac/config/lib.inc'
# Or load the ORAC_LIB environment variable, which is what the Makefile uses.
import os
try:
    ORAC_LIB = os.environ["ORAC_LIB"]
except KeyError
    ORAC_LIB = ORAC_DIR + '/config/lib.inc'

# Indicates the format of meteorological data used. The values are:
# 0. NOAA GFS data in a single GRIB file.
# 1. ECMWF Operational or ERA5 data as a single netCDF4 file
# 2. ECMWF ERA5 data in JASMIN format (GRIB, one file per variable)
# 3. DWD format (unknown details)
# 4. ERA-Interim in JASMIN format, three files (1 NCDF, 2 GRIB).
# This will be driven by the data you have access to but we recommend ERA5.
NWP_FLAG = 2

# The remaining paths are gathered in a dictionary. They can be changed for a
# single script call using the --aux/-x keyword, with default values here.
# If any of these directories contain subdirectories named by date, please use
# the syntax of datatime.strftime() to denote the folder structure.
AUXILIARIES = {
    # Directory containing RTTOV emissivity atlas
    # https://www.nwpsaf.eu/site/software/rttov/download/
    'atlas_dir': '/usr/lib/rtcoef_rttov12/emis_data',

    # Directory of RTTOV instrument coefficient files
    # www.nwpsaf.eu/site/software/rttov/download/coefficients/coefficient-download
    'coef_dir': '/usr/lib/rtcoef_rttov12',

    # Directory of MODIS emisivity retrievals
    # https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/myd11c3_v006
    'emis_dir': '/local/storage/modis_emis',

    # Directory of CAMEL emisivity retrievals, which are preferred
    # https://e4ftl01.cr.usgs.gov/MEASURES/CAM5K30EM.002/
    'camel_dir': '/local/storage/camel_emis',

    # Directories of MODIS surface BRDF retrievals
    # https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd43c1_v006
    # https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd43c3_v006
    'mcd43c1_dir': '/local/storage/modis/mcd43cX/%Y',
    'mcd43c3_dir': '/local/storage/modis/mcd43cX/%Y',

    # To use ECMWF data from the BADC/CEMS archive (ecmwf_flag == 4), specify
    # where each of the three types of file are stored
    #'ggam_dir': '/local/storage/ecmwf/era_interim/%Y/%m/%d',
    #'ggas_dir': '/local/storage/ecmwf/era_interim/%Y/%m/%d',
    #'spam_dir': '/local/storage/ecmwf/era_interim/%Y/%m/%d',

    # To use ERA5 (ecmwf_flag == 5), specify
    'ecmwf_dir': '/local/storage/era5/%Y/%m/%d',

    # Directory to store the EMOS interpolation file. LibEmos will put a file,
    # CF_T0255_R0036000, in your home directory unless the environment variable
    # PPDIR is set. This can be done in the conda activation so this variable
    # should be equal to os.environ['PPDIR'].
    'emos_dir': '/usr/lib/emos_files',

    # Directory of NSIDC ice/snow extent maps
    # https://n5eil01u.ecs.nsidc.org/SAN/OTHR/
    'nise_dir': '/local/storage/n5eil01u.ecs.nsidc.org/SAN/OTHR',

    # Directory of Ocean Colour CCI retrievals
    # ftp://ftp.rsg.pml.ac.uk/occci-v4.2/geographic/netcdf/monthly/chlor_a/
    'occci_dir': '/usr/lib/orac/data/occci/%Y',

    # File containing AATSR calibration coefficients. Can be '' when only using
    # ATSR >= version 2. A copy of the file can be found at
    # https://groups.physics.ox.ac.uk/eodg/orac/AATSR_VIS_DRIFT_V03-00.DAT
    'calib_file': '/usr/lib/AATSR_VIS_DRIFT_V03-00.DAT',

    # File containing the USGS land-use map. This is used to provide a land/sea
    # for the early NOAA satellites, which don't include one. We recommend
    # using --l1_land_mask or the geostationary files instead (and intend to
    # make that the default behaviour eventually).
    # https://groups.physics.ox.ac.uk/eodg/orac/Aux_file_CM_SAF_AVHRR_GAC_ori_0.05deg.nc
    'usgs_file': '/usr/lib/Aux_file_CM_SAF_AVHRR_GAC_ori_0.05deg.nc',

    # Pre-defined geometry for geostationary imager. Please request if needed.
    'prelsm_file': '/usr/lib/orac/data/GEO_FILES/MSG_000E_LSM.nc',
    'pregeo_file': '/usr/lib/orac/data/GEO_FILES/MSG_000E_ANGLES.nc',

    # Climatology of Swansea s and p parameters. Please request if needed.
    'swansea_dir': '/usr/lib/swansea_cb',
}


# ==================== FILE HEADER INFORMATION ============================
GLOBAL_ATTRIBUTES = {
    "cfconvention": "CF-1.4",
    "comments": "n/a",

    # Put your own email here
    "email": 'user.name@orac.ac.uk',

    "history": "n/a",

    # Put your own institute here
    "institute": "Liberator",

    "keywords": "aerosol; cloud; optimal estimation",
    "license": "https://github.com/ORAC-CC/orac/blob/master/COPYING",
    "processor": "ORAC",

    # These adjust the default filename
    "product_name": "L2-CLOUD-CLD",
    "project": "ESACCI",

    "references": "doi:10.5194/amt-5-1889-2012",
    "summary": "n/a",
    "url": "http://github.com/ORAC-CC/orac",
}


# ======================= FOLDER NAME PREFERENCES =========================
# The scripts will generate these subdirectories to store intermediary and
# log files.
LOG_DIR = "log"
PRE_DIR = "pre"

# Some users desire specific control over each retrieval. If there are settings
# you routinely wish used for all aerosol retrievals over land or sea or cloud
# retrievals, put those (as raw driver file input) in a file and put the path to
# each file here. Otherwise, leave as is.
EXTRA_LINES = {
    "land_extra": "",
    "sea_extra": "",
    "cld_extra": "",
}


# ===================== DEFAULT RETRIEVAL SETTINGS ========================
"""This section outlines the default arguments for retrievals as a function
of the lut name and instrument. Inexperienced users should not edit this.

The RETRIEVAL_SETTINGS dictionary is used by the Python scripts to interpret
command line arguments. When the script is called with `-S tag`, the script
iterates over each element of the list retrieval_settings[tag], appending that
text to the current script call and parsing it like other arguments.

The code below outlines our current recommended retrievals. These are tagged
with the instrument name (AATSR, ATSR2, AVHRR, MODIS, SEVIRI), an underscore,
and a tag. C tags cloud retrievals, A aerosol retrievals, and J a joint aerosol-
cloud run.

For example, RETRIEVAL_SETTINGS["MODIS_C"] = [
    '--use_channels 1 2 6 20 31 32 --lut_name WAT --ret_class ClsCldWat --approach AppCld1L --sub_dir cld',
    '--use_channels 1 2 6 20 31 32 --lut_name ICE --ret_class ClsCldIce --approach AppCld1L --sub_dir cld',
    '--use_channels 1 2 6 20 31 32 --lut_name WAT --ret_class ClsCldWat --approach AppCld2L --multilayer ICE ClsCldIce --sub_dir cld'
]
Thus, if you call `orac.py -S MODIS_C $SOME_MODIS_FILE`, the ORAC processor will
be called 3 times as there are three elements in this array. Each line contains,
'--use_channels 1 2 6 20 31 32' to specify 6 channels to use in the retrieval
and '--sub_dir cld' to indicate that output files should be stored in a
subdirectory called 'cld'. Then, the first call will consider single-layer water
cloud and the second single-later ice cloud (from the --lut_name argument). The
third call will evaluate a layer of ice cloud (--multilayer) above water.
"""

RETRIEVAL_SETTINGS = {}

# Permute a set of standard cloud retrievals over each sensor
_CLD_RETRIEVALS = {
    "wat_cld": "--lut_name WAT --ret_class ClsCldWat --approach AppCld1L "
               "--sub_dir cld",
    "ice_cld": "--lut_name ICE --ret_class ClsCldIce --approach AppCld1L "
               "--sub_dir cld",
    "wat_ice": "--lut_name ICE --ret_class ClsCldIce --approach AppCld2L "
               "--multilayer WAT ClsCldWat --sub_dir cld",
#    "ice_ice": "--lut_name ICE --ret_class ClsCldIce --approach AppCld2L "
#               "--multilayer ICE ClsCldIce --sub_dir cld"
}
_CLD_CHANNELS = {
    "AATSR": "--use_channels 2 3 4 5 6 7",
    "ATSR2": "--use_channels 2 3 4 5 6 7",
    "AVHRR": "--use_channels 1 2 3 4 5 6",
    "MODIS": "--use_channels 1 2 6 20 31 32",
    "SEVIRI": "--use_channels 1 2 3 4 9 10",
    "SLSTR": "--use_channels 2 3 5 7 8 9",
}
for sensor, channels in _CLD_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_C"] = [
        channels + " " + ret for ret in _CLD_RETRIEVALS.values()
    ]

# Permute dual-view aerosol retrievals
_AER_PHASES = range(70, 80)
_AER_DUAL_RETRIEVALS = {
    "aer_ox": "--lut_name A{:02d} --ret_class ClsAerOx --approach AppAerOx "
              "--no_land --sub_dir sea",
    "aer_sw": "--lut_name A{:02d} --ret_class ClsAerSw --approach AppAerSw "
              "--no_sea --sub_dir land",
}
_AER_DUAL_CHANNELS = {
    "AATSR": "--use_channels 1 2 3 4 8 9 10 11",
    "ATSR2": "--use_channels 1 2 3 4 8 9 10 11",
    "SLSTR": "--use_channels 1 2 3 5 10 11 12 14",
}
for sensor, channels in _AER_DUAL_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_A"] = [
        channels + " " + ret.format(phs)
        for ret in _AER_DUAL_RETRIEVALS.values() for phs in _AER_PHASES
    ]

# Permute single-view aerosol retrievals
_AER_SINGLE_RETRIEVALS = {
    "aer_o1": "--lut_name A{:02d} --ret_class ClsAerOx --approach AppAerO1 "
               "--no_land --sub_dir sea",
}
_AER_SINGLE_CHANNELS = {
    "AVHRR": "--use channels 1 2 3",
    "MODIS": "--use_channels 4 1 2 6",
    "SEVIRI": "--use_channels 1 2 3",
}
for sensor, channels in _AER_SINGLE_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_A"] = [
        channels + " " + ret.format(phs)
        for ret in _AER_SINGLE_RETRIEVALS.values() for phs in _AER_PHASES
    ]

# Joint aerosol-cloud retrievals
for sensor, channels in _CLD_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_J"] = [
        channels + " " + ret for ret in _CLD_RETRIEVALS.values()
    ]
for sensor, channels in _AER_DUAL_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_J"].extend([
        channels + " " + ret.format(phs)
        for ret in _AER_DUAL_RETRIEVALS.values() for phs in _AER_PHASES
    ])
for sensor, channels in _AER_SINGLE_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_J"].extend([
        channels + " " + ret.format(phs)
        for ret in _AER_SINGLE_RETRIEVALS.values() for phs in _AER_PHASES
    ])

# Default to cloud retrievals
for sensor in _CLD_CHANNELS.keys():
    RETRIEVAL_SETTINGS[sensor] = RETRIEVAL_SETTINGS[sensor + "_C"]


# ================== DEFAULT CHANNELS FOR EACH SENSOR =====================
# If --use_channels is not specified in a call, this dictionary gives the
# channels to read for each instrument. The names derive from the 'sensor'
# field of a FileName instance.
CHANNELS = {
    "AATSR": (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11),
    "ATSR2": (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11),
    "AVHRR": (1, 2, 3, 4, 5, 6),
    "MODIS": (1, 2, 6, 20, 31, 32),
    "SEVIRI": (1, 2, 3, 4, 5, 6, 7, 9, 10, 11),
    "SLSTR": (1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 14),
}


# ==================== REGRESSION TEST SETTINGS ===========================
# Fields to ignore during regression testing
ATTS_TO_IGNORE = ('L2_Processor_Version', 'Production_Time', 'File_Name')
VARS_TO_ACCEPT = ('costjm', 'costja', 'niter')

# Tollerances in regression testing
RTOL = 1e-7 # Maximum permissable relative difference
ATOL = 1e-7 # Maximum permissable absolute difference

# Filters to apply regression test warnings
# (see https://docs.python.org/2/library/warnings.html#the-warnings-filter)
WARN_FILT = {
    'FieldMissing': 'once',
    'InconsistentDim': 'error',
    'RoundingError': 'once',
    'Acceptable': 'once',
}


# ===================== BATCH PROCESSING SETTINGS =========================
# This specifies which batch queueing system you use, from pyorac.batch.
from pyorac.batch import BSUB as BATCH

# The batch queuing object takes a dictionary of settings. This specifies
# values to use in every call. The example below states we should always email
# the address given above if a job fails, we should have a priority of 10,000 and
# use the queue 'priority'.
BATCH_VALUES = {
    'email': global_attributes["email"],
    'priority': 10000,
    'queue': 'priority',
}

# When running on a batch queue, ORAC is called from temporary scripts, which
# setup the running environment. This string defines how these scripts start.
# In this case, we use the default bash client but specify that this should not
# load my .profile file, as I'm loading those variables internally. We also
# set that the script should exit when it encounters an error.
batch_script = """#!/bin/bash --noprofile
set -e
"""

# These scripts create folders as necessary, with the following permissions.
DIR_PERMISSIONS = 0o774


# ============================ LUT SETTINGS ===============================
"""This section defines which look-up tables are available on your local
system, giving each a singular name you will use to refer to that table
with the --lut_name argument for --settings. These are defined through:

LUT_LOOKUP
    dict of functions. Keys are the names used to refer to different
    particle types (e.g. WAT, cci70, biomass-burning) and will be
    used in the ORAC filename as this is passed to Ctrl%LUTclass.
    Functions should take two arguments,
      instrument (pyorac.definition.FileName): sensor description;
      rayleigh (bool): sets if Rayleigh scattering is included in LUT.
    Functions should return a 4-tuple of,
      sad_dir (str): path to the desired LUT;
      sad_file (str): name of the NCDF file to open OR None for text tables;
      particle_type (str): LUT name passed to ORAC;
      prior_type (str): key to pass to APRIORI_LOOKUP which describes
        the a-priori information to pass via driver file OR None.
"""

LUT_LOOKUP = {
    # Text tables that are all in the same folder can be referenced easily,
    # as there is no need to use functions.
    'WAT': lambda _, _: (
        '/path/to/some/lut/folder/WAT', # The directory
        None, # No filename is passed for text tables
        'WAT', # This label can be the same as the dict key
        None # Cloud retrievals typically use the default a priori
    ),
    'ICE': lambda _, _: (
        '/path/to/some/lut/folder/ICE',
        None,
        'ICE',
        None
    ),
    'ICE-baran': lambda _, _: (
        '/path/to/some/lut/folder/ICE_baran',
        None,
        'ICE', # For text tables, this label *must* be three characters
        None
    ),
    # However, we usually put each instrument and style in a different directory
    'WAT-srf': lambda inst, rayleigh: (
        f'/foo/bar/{inst.sensor}_WAT_srf' + ('_no_ray' if rayleigh else ''),
        None,
        'WAT',
        None
    ),
    # Text aerosol tables, where rayleigh is ignored as tables must contain it
    'A70': lambda inst, _: (
        '/foo/bar/cci' if inst.sensor == 'SLSTR' else '/foo/bar/tables',
        None,
        'A70',
        'large_clean_aerosol' # Aerosol retrievals have unique a priori for
        # each particle type, typically setting a narrow range for effective
        # radius. These are defined in pyorac.processing_settings.APRIORI_LOOKUP
        # and this fourth element gives a key for that dict.
    ),
    'A71': lambda inst, _: (
        '/foo/bar/cci' if inst.sensor == 'SLSTR' else '/foo/bar/tables',
        None,
        'A71',
        'small_natural_aerosol'
    ),
    # NCDF tables are typically all in the same folder but must provide filename
    'liquid-water': lambda inst, ray: (
        '/some/where/ncdf',
        _ncdf_lut_filename(inst, 'liquid-water', 'old', rayleigh=ray),
        # This function is defined below
        'liquid-water', # This label is used in the ORAC filename and needs to
        # start with the general type but can be followed by your additions
        None
    ),
    '240k-water': lambda inst, ray: (
        '/some/where/ncdf',
        _ncdf_lut_filename(inst, 'liquid-water', '240', rayleigh=ray),
        'liquid-water240',
        None
    ),
    'water-ice': lambda inst, ray: (
        '/some/where/ncdf',
        _ncdf_lut_filename(inst, 'water-ice', 'agg', rayleigh=ray),
        'water-ice-agg',
        None
    ),
    'ghm-ice': lambda inst, ray: (
        '/some/where/ncdf',
        _ncdf_lut_filename(inst, 'water-ice', 'ghm', rayleigh=ray),
        'water-ice',
        None
    ),
    # NCDF aerosol tables
    'cci70': lambda inst, _: (
        '/some/where/ncdf',
        _ncdf_lut_filename(inst, 'aerosol', 'a70'),
        'aerosol70',
        'large_clean_aerosol'
    ),
    'cci75': lambda inst, _: (
        '/some/where/ncdf',
        _ncdf_lut_filename(inst, 'aerosol', 'a75'),
        'aerosol75',
        'manmade_aerosol'
    ),
}


def _ncdf_lut_filename(inst, label, microphysical_model, atmospheric_model=2,
                       rayleigh=True, srf=False):
    """Constructs name of NCDF LUT file following Don's convention

    inst - pyorac.definitions.FileName to label sensor
    label - label for particle classification
    mb  - 'm' for monochromatic calculation or 'b' for band calculation
           weighted by the spectral response function
    atmospheric_model - code denoting the atmospheric model where
                         00: cloud, no Rayleigh scattering
                         01: cloud, includes Rayleigh scattering
                         1X: aerosol, where X denotes the gaseous model where
                                1 = Tropical Atmosphere
                                2 = Midlatitude Summer
                                3 = Midlatitude Winter
                                4 = Subarctic Summer
                                5 = Subarctic Winter
                                6 = 1976 US Standard
    microphysical_model - Three digit code to represent particle microphysics.
                          Backwards compatible with old LUT naming
                          e.g. a70 for aerosol dust model
    version - LUT version
    """

    sensor_name = inst.sensor.lower()
    if sensor_name == 'avhrr':
        sensor_name += '1'

    mb = 'b' if srf else 'm'

    if label == 'aerosol':
        assert rayleigh
        atm_model = atmospheric_model + 10
    else:
        atm_model = 1 if rayleigh else 0

    # Logic which sets the version number to be used for each sensor
    # Could be replaced with a search for the most recent version
    if inst.sensor == 'EarthCARE':
        version = 21
    elif inst.sensor in ('AATSR', 'SLSTR'):
        version = 12
    elif inst.sensor in ('AVHRR', 'MODIS', 'SEVIRI'):
        version = 11
    elif inst.sensor in ('AHI'):
        version = 9
    else:
        version = 7

    return (f'{inst.ncdf_sad_platform}_{sensor_name}_{mb}_{label}_'
            f'a{atm_model:02d}_p{microphysical_model}_v{version:02d}.nc')
