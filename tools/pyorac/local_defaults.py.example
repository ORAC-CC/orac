"""Definitions of default values and paths for your local system.

The PyORAC scripts are designed to make it easy to run ORAC by automating
the process of locating all the necessary input files, generating correctly
formatted driver files, and setting up environment variables so the executables
can link against the correct libraries. Doing all of that requires knowing
where to find various things, and this file is where that information is kept.

Following Python style, global variables are in block capitals. Temporary
variables that are used to generate other variables, but aren't expected to be
used themselves, are prefixed with an underscore.

The first section defines a selection of paths that point the scripts to the
   various input files requires by ORAC.
The second section defines the metadata that goes in every ORAC output file.
The third section defines the names of subfolders that will be generated by
   these scripts.
The fourth section defines the default retrieval settings. Only experienced
   users should alter these but feel free to add your own options.
The fifth section defines the default channels to read from each sensor. Though
   different retrievals use different channels, for consistent cloud flagging
   one should read the same set of channels for any processing.
The sixth section sets up the regression tests.
The seventh section specifies the batch processing system to use.
"""

# ============================ PATHS ======================================
# Location of your copy of the ORAC repository. This is used to find executables.
ORAC_DIR = '/home/username/orac/orac'

# regression.py calls a set of predefined regression tests. The L1 files for
# those tests are expected to be found in a single folder (which could be
# symlinks to a more rational location), which is defined here.
REGRESS_IN_DIR = '/local/storage/orac/data'

# We also define a default output folder for the regression tests, as they
# want to find the output of previous regression tests to compare against.
REGRESS_OUT_DIR = '/local/storage/orac/regression_tests'

# Path to the library file used to compile ORAC. This is used by
# pyorac.util.build_orac_library_path() to set LD_LIBRARY_PATH. You can just
# type of the full path to your library file,
ORAC_LIB = '/home/username/orac/orac/config/lib.inc'
# Or load the ORAC_LIB environment variable, which is what the Makefile uses.
import os
try:
    ORAC_LIB = os.environ["ORAC_LIB"]
except KeyError
    ORAC_LIB = ORAC_DIR + '/config/lib.inc'

# Location of the look-up tables. Multiple locations can be set as a list.
SAD_DIRS = ['/local/storage/orac_luts', ]

# Indicates the format of meteorological data used. The values are:
# 0. NOAA GFS data in a single GRIB file.
# 1. ECMWF Operational or ERA5 data as a single netCDF4 file
# 2. ECMWF ERA5 data in JASMIN format (GRIB, one file per variable)
# 3. DWD format (unknown details)
# 4. ERA-Interim in JASMIN format, three files (1 NCDF, 2 GRIB).
# This will be driven by the data you have access to but we recommend ERA5.
NWP_FLAG = 2

# The remaining paths are gathered in a dictionary. They can be changed for a
# single script call using the --aux/-x keyword, with default values here.
# If any of these directories contain subdirectories named by date, please use
# the syntax of datatime.strftime() to denote the folder structure.
AUXILIARIES = {
    # Directory containing RTTOV emissivity atlas
    # https://www.nwpsaf.eu/site/software/rttov/download/
    'atlas_dir': '/usr/lib/rtcoef_rttov12/emis_data',

    # Directory of RTTOV instrument coefficient files
    # www.nwpsaf.eu/site/software/rttov/download/coefficients/coefficient-download
    'coef_dir': '/usr/lib/rtcoef_rttov12',

    # Directory of MODIS emisivity retrievals
    # https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/myd11c3_v006
    'emis_dir': '/local/storage/modis_emis',

    # Directory of CAMEL emisivity retrievals, which are preferred
    # https://e4ftl01.cr.usgs.gov/MEASURES/CAM5K30EM.002/
    'camel_dir': '/local/storage/camel_emis',

    # Directories of MODIS surface BRDF retrievals
    # https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd43c1_v006
    # https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mcd43c3_v006
    'mcd43c1_dir': '/local/storage/modis/mcd43cX/%Y',
    'mcd43c3_dir': '/local/storage/modis/mcd43cX/%Y',

    # To use ECMWF data from the BADC/CEMS archive (ecmwf_flag == 4), specify
    # where each of the three types of file are stored
    #'ggam_dir': '/local/storage/ecmwf/era_interim/%Y/%m/%d',
    #'ggas_dir': '/local/storage/ecmwf/era_interim/%Y/%m/%d',
    #'spam_dir': '/local/storage/ecmwf/era_interim/%Y/%m/%d',

    # To use ERA5 (ecmwf_flag == 5), specify
    'ecmwf_dir': '/local/storage/era5/%Y/%m/%d',

    # Directory to store the EMOS interpolation file. LibEmos will put a file,
    # CF_T0255_R0036000, in your home directory unless the environment variable
    # PPDIR is set. This can be done in the conda activation so this variable
    # should be equal to os.environ['PPDIR'].
    'emos_dir': '/usr/lib/emos_files',

    # Directory of NSIDC ice/snow extent maps
    # https://n5eil01u.ecs.nsidc.org/SAN/OTHR/
    'nise_dir': '/local/storage/n5eil01u.ecs.nsidc.org/SAN/OTHR',

    # Directory of Ocean Colour CCI retrievals
    # ftp://ftp.rsg.pml.ac.uk/occci-v4.2/geographic/netcdf/monthly/chlor_a/
    'occci_dir': '/usr/lib/orac/data/occci',

    # File containing AATSR calibration coefficients. Can be '' when only using
    # ATSR >= version 2. A copy of the file can be found at
    # https://groups.physics.ox.ac.uk/eodg/orac/AATSR_VIS_DRIFT_V03-00.DAT
    'calib_file': '/usr/lib/AATSR_VIS_DRIFT_V03-00.DAT',

    # File containing the USGS land-use map. This is used to provide a land/sea
    # for the early NOAA satellites, which don't include one. We recommend
    # using --l1_land_mask or the geostationary files instead (and intend to
    # make that the default behaviour eventually).
    # https://groups.physics.ox.ac.uk/eodg/orac/Aux_file_CM_SAF_AVHRR_GAC_ori_0.05deg.nc
    'usgs_file': '/usr/lib/Aux_file_CM_SAF_AVHRR_GAC_ori_0.05deg.nc',

    # Pre-defined geometry for geostationary imager. Please request if needed.
    'prelsm_file': '/usr/lib/orac/data/GEO_FILES/MSG_000E_LSM.nc',
    'pregeo_file': '/usr/lib/orac/data/GEO_FILES/MSG_000E_ANGLES.nc',

    # Climatology of Swansea s and p parameters. Please request if needed.
    'swansea_dir': '/usr/lib/swansea_cb',
}


# ==================== FILE HEADER INFORMATION ============================
GLOBAL_ATTRIBUTES = {
    "cfconvention": "CF-1.4",
    "comments": "n/a",

    # Put your own email here
    "email": 'user.name@orac.ac.uk',

    "history": "n/a",

    # Put your own institute here
    "institute": "Liberator",

    "keywords": "aerosol; cloud; optimal estimation",
    "license": "https://github.com/ORAC-CC/orac/blob/master/COPYING",
    "processor": "ORAC",

    # These adjust the default filename
    "product_name": "L2-CLOUD-CLD",
    "project": "ESACCI",

    "references": "doi:10.5194/amt-5-1889-2012",
    "summary: "n/a",
    "url": "http://github.com/ORAC-CC/orac",
}


# ======================= FOLDER NAME PREFERENCES =========================
# The scripts will generate these subdirectories to store intermediary and
# log files.
LOG_DIR = "log"
PRE_DIR = "pre"

# Some users desire specific control over each retrieval. If there are settings
# you routinely wish used for all aerosol retrievals over land or sea or cloud
# retrievals, put those (as raw driver file input) in a file and put the path to
# each file here. Otherwise, leave as is.
EXTRA_LINES = {
    "land_extra": "",
    "sea_extra": "",
    "cld_extra": "",
}


# ===================== DEFAULT RETRIEVAL SETTINGS ========================
"""This section outlines the default arguments for retrievals as a function
of the particle phase and instrument. Inexperienced users should not edit this.

The RETRIEVAL_SETTINGS dictionary is used by the Python scripts to interpret
command line arguments. When the script is called with `-S tag`, the script
iterates over each element of the list retrieval_settings[tag], appending that
text to the current script call and parsing it like other arguments.

The code below outlines our current recommended retrievals. These are tagged
with the instrument name (AATSR, ATSR2, AVHRR, MODIS, SEVIRI), an underscore,
and a tag. C tags cloud retrievals, A aerosol retrievals, and J a joint aerosol-
cloud run.

For example, RETRIEVAL_SETTINGS["MODIS_C"] = [
    '--use_channels 1 2 6 20 31 32 --phase WAT --ret_class ClsCldWat --approach AppCld1L --sub_dir cld',
    '--use_channels 1 2 6 20 31 32 --phase ICE --ret_class ClsCldIce --approach AppCld1L --sub_dir cld',
    '--use_channels 1 2 6 20 31 32 --phase WAT --ret_class ClsCldWat --approach AppCld2L --multilayer ICE ClsCldIce --sub_dir cld'
]
Thus, if you call orac.py -S MODIS_C $SOME_MODIS_FILE, the ORAC processor will be
called 3 times as there are three elements in this array. Each line contains,
'--use_channels 1 2 6 20 31 32' to specify 6 channels to use in the retrieval
and '--sub_dir cld' to indicate that output files should be stored in a
subdirectory called 'cld'. Then, the first call will consider single-layer water
cloud and the second single-later ice cloud (from the --phase argument). The
third call will evaluate a layer of ice cloud (--multilayer) above water.
"""

RETRIEVAL_SETTINGS = {}

# Permute a set of standard cloud retrievals over each sensor
_CLD_RETRIEVALS = {
    "wat_cld": "--phase WAT --ret_class ClsCldWat --approach AppCld1L "
               "--sub_dir cld",
    "ice_cld": "--phase ICE --ret_class ClsCldIce --approach AppCld1L "
               "--sub_dir cld",
    "wat_ice": "--phase ICE --ret_class ClsCldIce --approach AppCld2L "
               "--multilayer WAT ClsCldWat --sub_dir cld",
#    "ice_ice": "--phase ICE --ret_class ClsCldIce --approach AppCld2L "
#               "--multilayer ICE ClsCldIce --sub_dir cld"
}
_CLD_CHANNELS = {
    "AATSR": "--use_channels 2 3 4 5 6 7",
    "ATSR2": "--use_channels 2 3 4 5 6 7",
    "AVHRR": "--use_channels 1 2 3 4 5 6",
    "MODIS": "--use_channels 1 2 6 20 31 32",
    "SEVIRI": "--use_channels 1 2 3 4 9 10",
    "SLSTR": "--use_channels 2 3 5 7 8 9",
}
for sensor, channels in _CLD_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_C"] = [
        channels + " " + ret for ret in _CLD_RETRIEVALS.values()
    ]

# Permute dual-view aerosol retrievals
_AER_PHASES = range(70, 80)
_AER_DUAL_RETRIEVALS = {
    "aer_ox": "--phase A{:02d} --ret_class ClsAerOx --approach AppAerOx "
              "--no_land --sub_dir sea",
    "aer_sw": "--phase A{:02d} --ret_class ClsAerSw --approach AppAerSw "
              "--no_sea --sub_dir land",
}
_AER_DUAL_CHANNELS = {
    "AATSR": "--use_channels 1 2 3 4 8 9 10 11",
    "ATSR2": "--use_channels 1 2 3 4 8 9 10 11",
    "SLSTR": "--use_channels 1 2 3 5 10 11 12 14",
}
for sensor, channels in _AER_DUAL_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_A"] = [
        channels + " " + ret.format(phs)
        for ret in _AER_DUAL_RETRIEVALS.values() for phs in _AER_PHASES
    ]

# Permute single-view aerosol retrievals
_AER_SINGLE_RETRIEVALS = {
    "aer_o1": "--phase A{:02d} --ret_class ClsAerOx --approach AppAerO1 "
               "--no_land --sub_dir sea",
}
_AER_SINGLE_CHANNELS = {
    "AVHRR": "--use channels 1 2 3",
    "MODIS": "--use_channels 4 1 2 6",
    "SEVIRI": "--use_channels 1 2 3",
}
for sensor, channels in _AER_SINGLE_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_A"] = [
        channels + " " + ret.format(phs)
        for ret in _AER_SINGLE_RETRIEVALS.values() for phs in _AER_PHASES
    ]

# Joint aerosol-cloud retrievals
for sensor, channels in _CLD_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_J"] = [
        channels + " " + ret for ret in _CLD_RETRIEVALS.values()
    ]
for sensor, channels in _AER_DUAL_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_J"].extend([
        channels + " " + ret.format(phs)
        for ret in _AER_DUAL_RETRIEVALS.values() for phs in _AER_PHASES
    ])
for sensor, channels in _AER_SINGLE_CHANNELS.items():
    RETRIEVAL_SETTINGS[sensor + "_J"].extend([
        channels + " " + ret.format(phs)
        for ret in _AER_SINGLE_RETRIEVALS.values() for phs in _AER_PHASES
    ])

# Default to cloud retrievals
for sensor in _CLD_CHANNELS.keys():
    RETRIEVAL_SETTINGS[sensor] = RETRIEVAL_SETTINGS[sensor + "_C"]


# ================== DEFAULT CHANNELS FOR EACH SENSOR =====================
# If --use_channels is not specified in a call, this dictionary gives the
# channels to read for each instrument. The names derive from the 'sensor'
# field of a FileName instance.
CHANNELS = {
    "AATSR": (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11),
    "ATSR2": (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11),
    "AVHRR": (1, 2, 3, 4, 5, 6),
    "MODIS": (1, 2, 6, 20, 31, 32),
    "SEVIRI": (1, 2, 3, 4, 9, 10),
    "SLSTR": (1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 14),
}


# ==================== REGRESSION TEST SETTINGS ===========================
# Fields to ignore during regression testing
ATTS_TO_IGNORE = ('L2_Processor_Version', 'Production_Time', 'File_Name')
VARS_TO_ACCEPT = ('costjm', 'costja', 'niter')

# Tollerances in regression testing
RTOL = 1e-7 # Maximum permissable relative difference
ATOL = 1e-7 # Maximum permissable absolute difference

# Filters to apply regression test warnings
# (see https://docs.python.org/2/library/warnings.html#the-warnings-filter)
WARN_FILT = {
    'FieldMissing': 'once',
    'InconsistentDim': 'error',
    'RoundingError': 'once',
    'Acceptable': 'once',
}


# ===================== BATCH PROCESSING SETTINGS =========================
# This specifies which batch queueing system you use, from pyorac.batch.
from pyorac.batch import BSUB as BATCH

# The batch queuing object takes a dictionary of settings. This specifies
# values to use in every call. The example below states we should always email
# the address given above if a job fails, we should have a priority of 10,000 and
# use the queue 'priority'.
BATCH_VALUES = {
    'email': global_attributes["email"],
    'priority': 10000,
    'queue': 'priority',
}

# When running on a batch queue, ORAC is called from temporary scripts, which
# setup the running environment. This string defines how these scripts start.
# In this case, we use the default bash client but specify that this should not
# load my .profile file, as I'm loading those variables internally. We also
# set that the script should exit when it encounters an error.
batch_script = """#!/bin/bash --noprofile
set -e
"""

# These scripts create folders as necessary, with the following permissions.
DIR_PERMISSIONS = 0o774
